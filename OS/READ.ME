# 1. Ecosystem Guide

Note:

It is recommended that you set $LC_ALL variable.
To check whether it is set, type the following command into a terminal:
echo $LC_ALL
If it returns an empty line, set it up by typing the following command into the terminal:

$ export LC_ALL=C

This line can also be added to the end of .bashrc and will automatically set the $LC_ALL variable each time the terminal is started.

Note:

It is not possible to build an ecosystem on an encrypted home directory, since schroot can not access that directory. We recommend that you make a separate directory in home directory that is not encrypted e.g. /home/ecosystem_build

## 1.1. Red Pitaya ecosystem and applications
Here you will find the sources of various software components of the Red Pitaya system. The components are mainly contained in dedicated directories, however, due to the nature of the Xilinx SoC “All Programmable” paradigm and the way several components are interrelated, some components might be spread across many directories or found at different places one would expect.

directories	contents
api	librp.so API source code
api2	librp2.so API source code
Applications	WEB applications (controller modules & GUI clients)
apps-free	WEB application for the old environment (also with controller modules & GUI clients)
apps-tools	WEB interface home page and some system management applications
Bazaar	Nginx server with dependencies, Bazaar module & application controller module loader
fpga	FPGA design (RTL, bench, simulation and synthesis scripts) SystemVerilog based for newer applications
OS/buildroot	GNU/Linux operating system components
patches	Directory containing patches
scpi-server	SCPI server
Test	Command line utilities (acquire, generate, ...), tests

### 1.1.1. Supported platforms
Red Pitaya is developed on Linux (64bit Ubuntu 16.04), so Linux is also the only platform we support.

### 1.1.2. Software requirements
You will need the following to build the Red Pitaya components:

Various development packages.

# generic dependencies
sudo apt-get install make curl xz-utils
# U-Boot build dependencies
sudo apt-get install libssl-dev device-tree-compiler u-boot-tools
# secure chroot
sudo apt-get install schroot
# QEMU
sudo apt-get install qemu qemu-user qemu-user-static
# 32 bit libraries
sudo apt-get install lib32z1 lib32ncurses5 libbz2-1.0:i386 lib32stdc++6
Meson Build system (depends on Python 3) is used for some new code. It is not required but can be used during development on x86 PC.

sudo apt-get install python3 python3-pip
sudo pip3 install --upgrade pip
sudo pip3 install meson
sudo apt-get install ninja-build
Xilinx Vivado 2017.2 FPGA development tools. The SDK (bare metal toolchain) must also be installed, be careful during the install process to select it. Preferably use the default install location.
Missing gmake path

Vivado requires a gmake executable which does not exist on Ubuntu. It is necessary to create a symbolic link to the regular make executable.

$ sudo ln -s /usr/bin/make /usr/bin/gmake

## 1.2. Build process
Go to your preferred development directory and clone the Red Pitaya repository from GitHub. The choice of specific branches or tags is up to the user.

git clone https://github.com/RedPitaya/RedPitaya.git
cd RedPitaya
An example script settings.sh is provided for setting all necessary environment variables. The script assumes some default tool install paths, so it might need editing if install paths other than the ones described above were used.

$ . settings.sh
Prepare a download cache for various source tarballs. This is an optional step which will speedup the build process by avoiding downloads for all but the first build. There is a default cache path defined in the settings.sh script, you can edit it and avoid a rebuild the next time.

mkdir -p dl
export DL=$PWD/dl
Download the ARM Ubuntu root environment (usually the latest) from Red Pitaya download servers. You can also create your own root environment following instructions in OS image build instructions. Correct file permissions are required for schroot to work properly.

wget http://downloads.redpitaya.com/downloads/redpitaya_ubuntu_13-14-23_25-sep-2017.tar.gz
sudo chown root:root redpitaya_ubuntu_13-14-23_25-sep-2017.tar.gz
sudo chmod 664 redpitaya_ubuntu_13-14-23_25-sep-2017.tar.gz
Create schroot configuration file /etc/schroot/chroot.d/red-pitaya-ubuntu.conf. Replace the tarball path stub with the absolute path of the previously downloaded image. Replace user names with a comma separeted list of users whom should be able to compile Red Pitaya.

[red-pitaya-ubuntu]
description=Red Pitaya Debian/Ubuntu OS image
type=file
file=absolute-path-to-red-pitaya-ubuntu.tar.gz
users=comma-seperated-list-of-users-with-access-permissions
root-users=comma-seperated-list-of-users-with-root-access-permissions
root-groups=root
profile=desktop
personality=linux
preserve-environment=true
To build everything a few make steps are required.

make -f Makefile.x86
schroot -c red-pitaya-ubuntu <<- EOL_CHROOT
make
EOL_CHROOT
make -f Makefile.x86 zip
To get an itteractive ARM shell do.

schroot -c red-pitaya-ubuntu

## 1.3. Partial rebuild process
The next components can be built separately.

FPGA + device tree
u-Boot
Linux kernel
Debian/Ubuntu OS
API
SCPI server
free applications

### 1.3.1. Base system
Here base system represents everything before Linux user space.

To be able to compile FPGA and cross compile base system software, it is necessary to setup the Vivado FPGA tools and ARM SDK.

$ . settings.sh
On some systems (including Ubuntu 16.04) the library setup provided by Vivado conflicts with default system libraries. To avoid this, disable library overrides specified by Vivado.

$ export LD_LIBRARY_PATH=""
After building the base system it can be installed into the directory later used to create the FAT filesystem compressed image.

$ make -f Makefile.x86 install

#### 1.3.1.1. FPGA and device tree sources
$ make -f Makefile.x86 fpga
Detailed instructions are provided for building the FPGA including some device tree details.

### 1.3.2. Device Tree compiler + overlay patches
Download the Device Tree compiler with overlay patches from Pantelis Antoniou. Compile and install it. Otherwise a binary is available in tools/dtc.

$ sudo apt-get install flex bison
$ git clone git@github.com:pantoniou/dtc.git
$ cd dtc
$ git checkout overlays
$ make
$ sudo make install PREFIX=/usr

#### 1.3.2.1. U-boot
To build the U-Boot binary and boot scripts (used to select between booting into Buildroot or Debian/Ubuntu):

make -f Makefile.x86 u-boot
The build process downloads the Xilinx version of U-Boot sources from Github, applies patches and starts the build process. Patches are available in the patches/ directory.

#### 1.3.2.2. Linux kernel and device tree binaries
To build a Linux image:

$ make -f Makefile.x86 linux
$ make -f Makefile.x86 linux-install
$ make -f Makefile.x86 devicetree
$ make -f Makefile.x86 devicetree-install

The build process downloads the Xilinx version of Linux sources from Github, applies patches and starts the build process. Patches are available in the patches/ directory.

## 1.1. Boot file
The created boot file contains FSBL, FPGA bitstream and U-Boot binary.

$ make -f Makefile.x86 boot


# 2. Red Pitaya OS
Note

To build an SD card image ecosystem is needed.

## 2.1. Dependencies
Ubuntu 2016.04.2 was used to build Debian/Ubuntu SD card images for Red Pitaya.

The next two packages need to be installed on the host PC:

$ sudo apt-get install debootstrap qemu-user-static

## 2.2. SD card image build Procedure
Multiple steps are needed to prepare a proper SD card image.

Bootstrap Debian system with network configuration and Red Pitaya specifics.
Add Red Pitaya ecosystem ZIP.

### 2.2.1. Ubuntu bootstrap
Run the next command inside the project root directory. Root or sudo privileges are needed.

$ sudo bash
# OS/debian/image.sh
# exit
image.sh will create an SD card image with a name containing the current date and time. Two partitions are created a 128MB FAT32 partition and a slightly less then 4GB Ext4 partition.

image.sh will call ubuntu.sh which installs the base system and some additional packages. It also configures APT (Debian packaging system), locales, hostname, timezone, file system table, U-boot and users (access to UART console).

ubuntu.sh also executes network.sh which creates a systemd-networkd based wired and wireless network setup. And it executes redpitaya.sh which installs additional Debian packages (mostly libraries) needed by Red Pitaya applications. redpitaya.sh also extracts ecosystem*.zip (if one exists in the current directory) into the FAT partition.

Optionally (code can be commented out) ubuntu.sh also executes jupyter.sh and tft.sh which provide additional functionality.

The generated image can be written to a SD card using the dd command or the Disks tool (Restore Disk Image).

$ dd bs=4M if=debian_armhf_*.img of=/dev/sd?
Note

To get the correct destination storage device, read the output of dmesg after you insert the SD card. If the wrong device is specified, the content of another drive may be overwritten, causing permanent loose of user data.

### 2.2.2. Red Pitaya ecosystem extraction
In case an ecosystem*.zip file was not available for the previous step, it can be extracted later to the FAT partition (128MB) of the SD card. In addition to Red Pitaya tools, this ecosystem ZIP file contains a boot image (containing FPGA code), a boot script (u-boot.scr) and the Linux kernel.

A script image-update.sh is provided for updating an existing image to a newer ecosystem zippfile without making modifications to the ext4 partition.

The script should be run with the image and ecosystem files as arguments:

# ./image-update.sh redpitaya_ubuntu_*.img ecosystem*.zip

### 2.2.3. File system check
If the image creation involved multiple steps performed by the user, for example some installation/setup procedure performed on a live Red Pitaya, there is a possibility a file system might be corrupted. The image-fsck.sh script performs a file system check without changing anything.

Use this script on an image before releasing it.

# ./image-fsck.sh redpitaya_ubuntu_*.img

### 2.2.4. Reducing image size
A cleanup can be performed to reduce the image size. Various things can be done to reduce the image size:

remove unused software (this could be software which was needed to compile applications)
remove unused source files (remove source repositories used to compile applications)
remove temporary files
zero out empty space on the partition
The next code only removes APT temporary files and zeros out the filesystem empty space.

$ apt-get clean
$ cat /dev/zero > zero.file
$ sync
$ rm -f zero.file
$ history -c